#!/usr/bin/python
# -*- coding:utf-8 -*-
import numpy as np
import random
import time
import threading
import win32api
import re
from fractions import Fraction


# 生成指定数量的随机运算符
def produce_operators(op_num=3):
    op = []                        # 记录生成的op_num个四则运算操作数
    for i in xrange(op_num):
        temp = random.choice(['＋','－','×','÷'])
        op.append(temp)
    return op

# 生成指定数量的随机整数和随机真分数
def produce_numbers(int_num=2,pro_frac_num=2):
    num = []                      # 记录生成的op_num+1个数（包括整数和真分数）
    for i in xrange(int_num):
        int_number = random.randint(0,1)
        temp = Fraction(int_number, 1)  # 生成随机整数
        num.append(temp)
    for i in xrange(pro_frac_num):
        denominator = random.randint(1,2)  # 分母（分母不为0）
        numerator = random.randint(0,denominator-1) # 分子
        proper_fraction = Fraction(numerator,denominator) # 生成随机真分数
        num.append(proper_fraction)
    return num

# 生成题目
def produce_problem(op_num,num,op):
    problem = []
    for i in xrange(op_num):
        number = random.choice(num)
        problem.append(number)
        num.remove(number)
        operator = random.choice(op)
        problem.append(operator)
        op.remove(operator)
        if i == op_num-1:
            problem.append(num[0])
    return problem

# 打印题目
def display_problem(problem):
    record_problem = ''
    for i in problem:
        temp = str(i)
        record_problem = record_problem +temp
    record_problem = record_problem + '='
    isrepetition(record_problem + '    ')
    print record_problem,
    return record_problem

# 计算题目正确结果
def calculate_result(problem):
    result = ''
    for i in problem:
        if type(i) == type(Fraction(2,3)):
            numerator_temp = i.numerator
            denominator_temp = i.denominator
            temp = 'Fraction(%d,%d)'%(numerator_temp,denominator_temp)
        else:
            if i == '＋':
                temp = '+'
            elif i == '－':
                temp = '-'
            elif i == '×':
                temp = '*'
            else:
                temp = '/'
        result = result + temp
    final_result = str(eval(result))
    #print result
    #print final_result
    return final_result

#记录答题信息
def record_message(show_problem,result,answer,judge_result):
    message = []
    message.append(str(show_problem) + '    ')
    message.append(str(result) + '    ')
    message.append(str(answer) + '    ')
    message.append(str(judge_result) + '    \n')
    return np.array(message)

# 判断答题者答案是否正确
def judge(answer,result):
    if answer == result:          # 判断正误
        print u'回答正确！'
        return 1
    else:
        print u'回答错误！正确答案是: %s'%(result)
        return 0

# 判断题目是否有可能重复（设置异常）
def isrepetition(problem):
    global test_data
    if problem in test_data[:,0]:
        raise NameError

# 对答题者进行测试
def test():
    global message_flag
    op_num = random.randint(1,2)  # 随机生成的运算符个数
    pro_frac_num = random.randint(0,op_num)  # 随机生成的真分数个数
    int_num = op_num + 1 - pro_frac_num  # 生成整数个数
    op = produce_operators(op_num)        # 随机生成指定数量的运算符
    num = produce_numbers(int_num, pro_frac_num)   # 生成指定数量的随机整数和随机真分数
    problem = produce_problem(op_num, num, op)     # 生成题目
    result = calculate_result(problem)             # 计算题目正确结果
    show_problem = display_problem(problem)        # 打印题目
    answer = raw_input('')                        # 读入答题者答案
    if message_flag == 0:
        print u'测试时间到！'
        return ['--------------------------------    ','--------------------------------    ','','']
    else:
        judge_result = judge(answer,result)            # 判断答题者答案
        return record_message(show_problem, result, answer, judge_result)

class timer(threading.Thread):
    def run(self):
        global message_flag
        global test_data
        while message_flag == 1:
            try:
                test_data = np.row_stack([test_data, test()])
            except ZeroDivisionError:
                # print u'四则运算题目除数不能为0'
                pass
            except NameError:
                # print u'该题重复！'
                pass


# 设计测试时间
def test_time(time0):
    global message_flag
    threadone = timer()
    threadone.start()
    time.sleep(time0)
    message_flag = 0

# 计算测试正确率
def calculate_accuracy():
    global test_data
    correct_question_num = 0
    total_question_num = test_data.shape[0] - 1
    for i in xrange(total_question_num):
        correct_question_num = correct_question_num + int(test_data[i,3])
    if total_question_num == 0:
        accuracy = "{:%}".format(0)
    else:

        accuracy = "{:%}".format(1.0*correct_question_num/total_question_num)
    test_data[total_question_num, 2] = str(total_question_num) + '    '
    test_data[total_question_num, 3] = str(accuracy) + '    \n'
    #print accuracy
    #print total_question_num
    return None

# 打印测试试题等信息
def output_testdata(name):
    global test_data
    test_data_path = '%s'%(name)
    f = open(test_data_path,'a')
    for i in xrange(test_data.shape[0]):
        f.write('（%d） '%(i+1))
        f.writelines(test_data[i])
        f.write('\n')
    f.close()


test_data = np.zeros([0, 4])  # 记录题目、正确答案、答题者答案、是否正确
message_flag = 1
if __name__=="__main__":
    test_or_practice = raw_input('输入test进入测试模式，输入practice进入练习模式，按其他任意键退出： ')
    if test_or_practice == 'test':
        time0 = float(raw_input('输入你想要设定的测试时间(s)： '))           # 设置测试时间
        test_time(time0)
        win32api.keybd_event(32, 0, 0, 0)       # 模拟按下键盘空格键
        win32api.keybd_event(13, 0, 0, 0)       # 模拟按下键盘回车键
        time.sleep(2)
        calculate_accuracy()                 # 计算本次测试答题者的正确率
        print_signal = raw_input('是否打印本次测试，输入yes打印，按其他任意键退出： ')
        if print_signal.lower() == 'yes':
            output_testdata('test_data.txt')
    elif test_or_practice == 'practice':
        n = int(raw_input('输入你想要的题目数量： '))
        while n > 0:
            try:
                test_data = np.row_stack([test_data, test()])
                n = n -1
            except ZeroDivisionError:
                # print u'四则运算题目除数不能为0'
                pass
            except NameError:
                # print u'该题重复！'
                pass
        print_signal = raw_input('是否打印本次测试，输入yes打印，按其他任意键退出： ')
        if print_signal.lower() == 'yes':
            output_testdata('practice_data.txt')
    else:
        pass



